#!/usr/bin/env python3
"""Show how OTP breaks if the keystream is non-random.

the message is a single byte, represented as an
integer in the range [0..255]. We use a strange OTP encryption
function: Before encryption, it repeats the number to be encrypted
10000 times. Then it encrypts it with a random key stream of the same
length by XORing the message byte(s) with the keystream
bytes. However, the key stream is not really random. One number in the
range [0..255] never occurs in the key stream.

this task is to write a function that breaks messages encrypted
with this faulty OTP implementation.
"""

import Cryptodome.Random.random as r


def encrypt(message, weakness):
    def faulty_random_number():
        """This is the faulty RNG."""
        while True:
            n = r.randint(0, 0xFF)
            if n != weakness:
                break
        return n

    # Message is repeated 10000 times. Each (identical) byte is
    # XORed with a random byte generated by our faulty RNG.
    return [message ^ faulty_random_number() for _ in range(10000)]


def break_cipher(ciphertext, weakness):
    # Write a function for breaking the cipher. Your function
    # shall return the original message (once, not 10000 times).
    ##################
    return weakness ^ get_missing_num(ciphertext)


def get_missing_num(ciphertext):
    for i in range(256):
        present = False
        for j in ciphertext:
            if j == i:
                present = True
                break
        if not present:
            return i
    return 0
    ##################

if __name__ == '__main__':
    # Let's test it!
    for _ in range(10):
        message = r.randint(0, 0xFF)
        weakness = r.randint(0, 0xFF)
        ciphertext = encrypt(message, weakness)
        assert ((break_cipher(ciphertext, weakness)) == message)
